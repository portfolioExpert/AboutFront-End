## 모던 자바스크립트 Deep Dive



### Chapter 11. 원시 값과 객체의 비교



##### 원시 값

- 변경 불가능한 값.

~~~javascript
var score;
score = 80; // 새로운 주소 값에 80이란 값을 할당 후 변수를 가리키게 한다.
~~~

- 불변성을 지녔다.
  - 원시 값을 교체할 수 있지만 직접 변형은 되지 않는다.



##### 값에 의한 전달

- 변수에 할당된 변수를 넣을 때 값이 복사되어 할당. 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

~~~javascript
var score = 80;
var copy = score;
~~~



##### 객체

- 객체는 변경 가능한 값이다. 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수 있다.



##### 참조에 의한 전달

- 여러개의 식별자가 하나의 객체를 공유하는 것을 의미



### Chapter 12. 함수

- 코드의 재사용성을 높이고 편의성을 높여주며 코드의 신뢰성을 높이는 효과로 함수는 객체 타입이다.



##### 함수 선언문과 함수 리터럴

~~~javascript
//함수 선언문

function foo(){
  console.log('foo');
}

//함수 리터럴
(function bar(){
  console.log('bar');
})

//함수 표현식
let bar = function (){
  console.log('bar');
}
console.log(bar());
~~~

- 함수 선언문은 foo라는 이름이 함수 객체를 가리키는 식별자를 함수가 포함된 스코프에 암묵적으로 생성하고 거기에 객체를 할당.
- 함수 리터럴은 함수 이름을 생략할 수 있고 함수 표현식으로 작성하여 함수처럼 동작하게 하지만 실제 동작과정은 다르다.



##### 함수 호이스팅

- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.
- 자바스크립트는 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당

> 함수 호이스팅 vs 변수 호이스팅
>
> var를 이용한 변수는 undefined로 초기화 되고 함수는 함수 객체로 초기화 되어 선언전 호출시 차이가 존재한다.

따라서, 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아니라 변수 호이스팅이 발생.



##### 화살표 함수(람다식)

- 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.



##### 함수 호출

- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 자바스크립트는 동적 타입 언어다. 따라서 매개변수의 타입을 사전에 지정할 수 없다.



##### 참조에 의한 전달과 외부 상태의 변경

- 원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작



~~~javascript
function changeVal(primitive, obj){
  primitive += 100;
  obj.name = 'Kim';
}

var num = 100;
var person = {name: 'Lee'};

console.log(num); //100
console.log(person); //{name: "Lee"}

changeVal(num, person);

console.log(num);//100
console.log(person); //{name: "Kim"}

~~~



##### 콜백함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차함수: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

~~~javascript
//고차함수
function repeat(n, f){
  for(var i = 0;i<n;i++){
    f(i);
  }
}

//콜백함수
var logAll = function (i){
  console.log(i);
};

repeat(5, logAll);//0, 1, 2, 3, 4

//콜백함수
var logOdds = function(i){
  if(i % 2) console.log(i);
}

repeat(5, logOdds);//1 3
~~~

- 콜백함수로 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성



##### 순수 함수와 비순수 함수

- 순수 함수: 외부상태를 변경하지 않는 함수
- 비순수 함수: 외부상태를 변경하는 함수로 부수효과가 있는 함수

>함수형 프로그래밍
>
>순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화 해서 불변성을 지향하는 프로그래밍 패러다임
