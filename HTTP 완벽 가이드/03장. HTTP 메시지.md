- 03장. HTTP 메시지

  ---

  ## 3.1 메시지의 흐름

  - HTTP는 애플리케이션 간에 주고받은 데이터 블록

  

  #### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

  - 인바운드: 메시지가 서버 방향으로
  - 아웃바운드: 사용자 에이전트 방향으로

  

  #### 3.1.2 다운스트림으로 흐르는 메시지

  - 모든 메시지는 다운스트림으로 흐른다.

  

  ---

  

  ## 3.2 메시지의 각 부분

  - 메시지는 request, response를 포함하며 시작줄, 헤더 블록, 본문으로 구성
  - Content-Type은 본문이 무엇인지 말해준다.

  

  #### 3.2.1 메시지 문법

  ~~~javascript
  //요청 메시지 형식
  <메서드><요청URL><버전>
  <헤더>
    
  <엔터티 본문>
    
  //응답 메시지 형식
  <버전><상태코드><사유 구절>
  <헤더>
    
  <엔터티 본문>
  ~~~

  - 메서드: HTTP 메서드로 get, post, put, patch
  - 요청 URL: 리소스를 지칭하는 URL 경로
  - 버전: HTTP 버전
  - 상태코드: 요청중에 무슨일이 일어났는지 설명하는 숫자
  - 사유 구절: 숫자로 된 상태코드의 의미를 이해할 수 있게 설명해주는 짧은 문구
  - 헤더들: 이름, 콜론, 선택적인 공백
  - 엔터티 본문: 임의의 데이터 블록을 포함한다. 보통 CRLF(빈 줄)로 끝난다.

  

  #### 3.2.2 시작줄

  - 모든 HTTP 메시지는 시작줄로 시작
  - 요청줄: 요청 메시지는 서버에게 리소스에 대해 무언가 해달라고 부탁하는 것으로 메소드와 동작에 대한 대상을 지칭하는 URL이 담겨 있다.
  - 응답줄: 클라이언트에게 돌려주는 것으로 HTTP 버전, 숫자로 된 상태코드, 수행 상태 메시지를 담아준다.
  - 메서드: 서버에게 무엇을 해야하는지 말해주는 것
  - 상태코드: 클라이언트에게 무엇이 일어났는지 말해주는 것

  ~~~
  100 ~ 101 : 정보
  200 ~ 206: 성공
  300 ~ 305 : 리다이렉션
  400 ~ 415 : 클라이언트 에러
  500 ~ 505 : 서버 에러
  ~~~

  - 사유 구절: 상태코드의 설명을 제공하는 것
  - 버전 번호: HTTP/x.y 형식으로 요청과 응답 메시지 양쪽에 모두 기술된다. 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 의미

  

  #### 3.2.3 헤더

  - 시작줄 다음에는 여러개의 HTTP 헤더가 온다
  - 헤더 분류: HTTP 헤더 명세는 여러 헤더 필드를 정의
  - 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있다.
  - 요청 헤더: 요청에 대한 부가 정보를 제공
  - 응답 헤더: 응답에 대한 부가 정보를 제공
  - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
  - 확장 헤더: 명세에 정의되지 않은 새로운 헤더
  - 헤더를 여러 줄로 나누기: 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.

  

  #### 3.2.4 엔터티 본문

  - HTTP가 수송하도록 설계된 것
  - HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션 등 디지털 데이터를 실어 나를 수 있다.

  

  #### 3.2.5 버전 0.9 메시지

  - 0.9 버전은 HTTP 초기 버전이다.

  <img src="./assets/HTTP 0.9.png">

  - 요청과 응답으로 이루어져 있지만, 요청은 메서드와 요청 URL을 가지고 있을 뿐이며, 응답은 엔터티로만 되어있다.
  - 버전 정보도 없고, 상태 코드나 사유 구절도 없고 헤더도 없다.

  참고: https://velog.io/@neity16/HTTP-HTTP-%EB%B2%84%EC%A0%84-%EB%B3%84-%ED%8A%B9%EC%A7%95

  ---

  

  ## 3.3 메서드

  #### 3.3.1 안전한 메서드

  - HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미
  - 작용이 없는 것은 HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미

  

  #### 3.3.2 GET

  - 서버에게 리소스를 달라고 요청하기 위해 쓰인다

  <img src="./assets/HTTP GET.png">


  #### 3.3.3 HEAD

  - 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.
  - 엔터티 본문은 결코 반환되지 않는다.
  - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입)를 알 수 있다.
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
  - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

  <img src="./assets/HTTP HEAD.png">


  #### 3.3.4 PUT

  - 서버에 문서를 쓰는 메서드
  - 리소스를 새로 만들거나 존재한다면 대체하는 메서드

  <img src="./assets/HTTP PUT.png">


  #### 3.3.5 POST

  - 서버에 입력 데이터를 전송하기 위한 메서드
  - HTML 폼을 지원하기 위해 사용된다.


  <img src="./assets/HTTP POST.png">


  #### 3.3.6 TRACE

  - 클라이언트가 요청할 때 방화벽, 프락시, 게이트웨이 등 애플리케이션을 통과할 수 있다. 이것은 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
  - 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

  ~~~
  1. Trace 요청은 목적지 서버에서 루프백 진단을 시작
  2. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 Trace 응답을 되돌려준다.
  3. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
  ~~~

  - 프락시는 POST 요청을 바로 서버로 통과시키는 반면 GET 요청은 웹 캐시와 다른 HTTP 애플리케이션으로 전송한다.

  <img src="./assets/HTTP TRACE.png">

  참고: https://devroach.tistory.com/117

  

  #### 3.3.7 OPTIONS

  - 웹 서버에게 여러 가지 종류의 지원 범위 대해 물어본다.
  - 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

  <img src="./assets/HTTP OPTIONS.png">


  #### 3.3.8 DELETE

  - 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
  - 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 이유는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문

  <img src="./assets/HTTP DELETE.png">


  #### 3.3.9 확장 메서드

  - HTTP는 필요에 따라 확장해도 문제 없도록 설계되어 있으므로 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.
  - 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드

  <img src="./assets/HTTP AddMethod.png">

  - LOCK: 사용자가 리소스를 잠글 수 있게 해준다.
  - MKCOL: 사용자가 문서를 생성할 수 있게 해준다.
  - COPY: 서버에 있는 리소스를 복사
  - MOVE: 서버에 있는 리소스를 옮긴다.

  

  ---

  ## 3.4 상태 코드

  #### 3.4.1 100-199: 정보성 상태 코드

  - 100(Continue): 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미
  - 101(Switching Protocols): 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미

  

  #### 3.4.2 200-299: 성공 상태 코드

  - 200 OK: 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.
  - 201 Created: 서버 개체를 생성하라는 요청을 위한 것. 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다.
  - 202 Accepted: 요청은 받아들여졌으나 아직 그에 대한 동작을 수행하지 않았다.
  - 203 Non-Authoritative: 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보를 검증하지 못한 경우 이런일이 발생할 수 있다.
  - 204 No Content: 응답 메시지는 헤더와 상태줄에 포함하지만 엔터티 본문은 포함하지 않는다.
  - 205 Reset Content: 주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.
  - 206 Partial Content: 부분 혹은 범위 요청이 성공했다.

  

  #### 3.4.3 300-399: 리다이렉션 상태 코드

  - 리소스에 대해 다른 위치로 이동했음을 알려주는 것

  <img src="./assets/HTTP Redirect.png">

  - 300 Multiple Choices: 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 리소스의 목록과 함께 반환한다.
  - 301 Moved Permanently: 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.
  - 302 Found: 301 상태코드와 같다.
  - 303 See Other: 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰인다. 새 URL은 응답 메시지의 Location 헤더에 들어있다.
  - 304 Not Modified: 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면 이 코드는 리소스가 수정되지 않았음을 의미
  - 305 Use Proxy: 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프락시의 위치는 Location 헤더를 통해 주어진다.
  - 307 Temporary Redirect: 301 상태 코드와 비슷하다.

  

  #### 3.4.4 400-499: 클라이언트 에러 상태 코드

  - 400 Bad Request: 클라이언트가 잘못된 요청을 보냈다고 말해준다.
  - 401 Unauthorized: 리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환
  - 402 Payment Required: 미래 사용을 위한 준비
  - 403 Forbidden: 인증은 되었지만 권한이 없을 경우 서버에 의해 거부되었음을 알려주기 위해 사용된다.
  - 404 Not Found: 서버가 요청 한 URL을 찾을 수 없음을 알려주기 위해 사용한다.
  - 405 Method Not Allowed: 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용한다.
  - 406 Not Acceptable: 클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없을 경우 사용한다.
  - 407 Proxy Authentication: 401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용.
  - 408 Request Timeout: 요청을 완수하기에 시간이 너무 많이 걸리는 경우 서버는 이 상태 코드를 응답하고 연결을 끊을 수 있다.
  - 409 Confilct: 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용한다.
  - 410 Gone: 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다르다.
  - 411 Length Required: 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용
  - 412 Precondition Failed: 클라이언트가 조건부 요청을 했는데 그 중 하나가 실패했을 때 사용한다. expect 헤더를 포함했을 때 발생
  - 413 Request Entity Too Large: 서버가 처리할 수 있는 한계를 넘은 크기 요청 URL이 포함된 요청을 보냈을 때 사용.
  - 414 Request URL Too long: 서버가 처리할 수 있는 한계를 넘은 길이 요청 URL이 포함된 요청을 보냈을 때 사용.
  - 415 Unsupported Media Type: 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 보냈을 때 사용.
  - 416 Requested Range Not Satisfiable: 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 사용.
  - 417 Expectation Failed: 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용한다.

  

  #### 3.4.5 500-599: 서버 에러 상태 코드

  - 프락시가 클라이언트 입장에서 서버와 대화를 할 때 자주 에러를 만나게 된다.
  - 500 Internal Server Error: 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용.
  - 501 Not Implemented: 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용.
  - 502 Bad Gateway: 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥드렸을 때 사용.
  - 503 Service Unavailable: 현재 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미하고자 할 때 사용.
  - 504 Gateway Timeout: 상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다.
  - 505 HTTP Version Not Supported: 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용.

  

  ---

  ## 3.5 헤더

  - 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

  

  #### 3.5.1 일반 헤더

  - 클라이언트와 서버 양쪽 모두가 사용
  - 일반 캐시 헤더: HTTP 1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.

  

  #### 3.5.2 요청 헤더

  - 요청 메시지를 위한 헤더이다. 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공
  - Accept 관련 헤더: 클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있다. 따라서, 클라이언트는 그들이 원하는 것을 얻을 수 있으며, 서버는 클라이언트가 사용할 수도 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있다.
  - 조건부 요청 헤더: 클라이언트는 요청에 몇몇 제약을 넣어 요청할 수 있다.
  - 요청 보안 헤더: HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다. 그것은 요청하는 클라이언트가 어느정도의 리소스에 접근하기 전에 자신을 입증하게 함으로써 트랜잭션을 약간 더 안전하게 만들고자 한다.

  

  #### 3.5.3 응답 헤더

  - 응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.
  - 누가 응답을 보내고 있는지 혹은 응답자의 능력은 어떻게 되는지 알려주며, 더 나아가 응답에 대한 특별한 설명도 제공.
  - 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와준다.

  

  #### 3.5.4 엔터티 헤더

  - 엔터티 본문에 대한 헤더를 의미.
  - 엔터티와 그것의 내용물에 대한, 개체의 타입부터 시작해서 주어진 리소스에 대해 요청할 수 있는 유요한 메서드들까지, 광범위한 정보를 제공한다.
  - 콘텐츠 헤더: 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.
  - 엔터티 캐싱 헤더: 엔터티 캐싱에 대한 정보를 제공. 캐시된 사본의 유효성 등
