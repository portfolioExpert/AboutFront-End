# 네트워크 정리 Ch2



## 1. 대칭키 공개키

- 참고: https://www.uname.in/m/129

- 암호화: 데이터를 보낼 때 그 데이터를 복호화 없이 보지 못하는 것
- 복호화: 암호된 데이터를 보기위한 인증과정



#### 1.1 대칭키

- 암호화와 복호화에 같은 암호키를 사용하는 알고리즘
- 동일한 키를 주고 받기 때문에, 매우 빠른 장점이 있다.
- 전달과정(키 교환)에서 해킹 위험에 노출이 있다.



#### 1.2 공개키(비대칭키)

- 암호화와 복호화에 사용하는 암호키를 분리한 알고리즘
- 대칭키의 키 교환 문제를 해결하기 위해 등장한 것
- 공개키는 모든 사람이 접근 가능한 키(공개되어 있다)
- 개인키(비밀키)는 각 사용자가 가지고 있는 키(공개키에 대응하는 키)
- 장점으로 키분배 필요없고 기밀성, 인증, 부인방지 기능을 제공
- 단점으로 대칭키 암호화 방식에 비해 속도가 느리다.



---



## 2. HTTPS 통신 과정



#### 2.1 들어가기 전

- 공개키 암호화 방식을 이용하며 SSL/TLS로 HTTP를 암호화 한 것

>SSL과 TLS
>
>SSL(Secure Sockets Layer): 웹사이트와 브라우저 사이(또는 두 서버 사이)에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술로 해커가 개인 데이터나 금융 데이터 등의 전송되는 정보를 보거나 훔치는 것을 방지
>
>TLS(Transport Layer Security): SSL의 향상된, 더욱 안전한 버전

- 작동 방식은 클라이언트와 서버간에 핸드셰이크를 통해 인증이 이루어 진다.



#### 2.2 HTTPS SSL 인증서 발급 과정

~~~javascript
1. 서버의 공개키와 비밀키를 생성한다.
2. 인증서를 발급받기 위해, 서버는 CA(인증기관)에 서버에서 생성한 공개키, 서버의 정보를 전달
3. CA에서 서버로부터 받은 정보들을 담아 SSL인증서로 발급
4. SSL 인증서를 암호화하기 위해 CA의 공개키, 비밀키를 생성하고 CA 비밀키를 이용 SSL 암호화를 한다.
5. 암호화된 SSL 인증서를 서버에 전달
~~~



#### 2.3 SSL 핸드셰이크 과정

참고: https://brunch.co.kr/@sangjinkang/38

- HTTPS 또한 HTTP 통신을 하기위해 3 - way - handshake를 거친다.
- 대칭키, 공개키 혼합 방식을 이용.

<img width="775" alt="스크린샷 2022-10-18 오전 7 57 47" src="https://user-images.githubusercontent.com/52316270/196641954-bad9b883-b9b4-43aa-bfb8-28e74df17c76.png">

~~~javascript
1. Client Hello: 브라우저가 사용하는 SSL 또는 TLS 버전 정보와 지원하는 암호화 방식,임의의 난수를 보냅니다.(핸드 셰이크 완료 상태시 세션 아이디만 서버에 알려준다.)
2. Server Hello: 브라우저의 암호화 방식 정보 중에서 서버가 지원하고 선택한 암호화 방식과 서버의 공개키가 담긴 SSL 인증서, 임의의 난수를 보냅니다.
3. 서버 인증서 확인: 브라우저는 서버의 SSL 인증서가 믿을만 한지 확인합니다.(CA에서 발급한 공개키로 복호화를 해본다.)
4. Premaster Secret: 브라우저는 자신이 생성한 난수와 서버의 난수를 이용해 premaster secret을 만듭니다.(인증서에 딸려온 웹 사이트 공개키로 암호화)
5. Premaster Secret 복호화: 서버는 사이트의 비밀키로, 브라우저가 보낸 premaster secret 값을 복호화 합니다. 이것을 사용해 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 session key를 생성한다(대칭키 암호화에 사용할 키).
6. SSL 핸드 셰이크를 종료하고, HTTPS 통신을 시작.(세션 유지시 브라우저는 세션 아이디만 알려주면 된다.)
~~~



---



## 3. Socket 통신과 HTTP 통신

###### 참고

https://kotlinworld.com/m/75

https://bentist.tistory.com/m/35



#### 3.1 HTTP 통신

- 초기엔 HTML 파일을 전송하는 프로토콜이라는 의미를 가졌지만 현재는 JSON, image 파일을 전송한다.
- HyperText Transfer Protocol로 하이퍼 텍스트를 주고 받기 위한 통신 규약을 의미

> 하이퍼 텍스트란?
>
> 연결 고리를 통해 다른 문서로 접근할 수 있는 텍스트를 말하며 HTML의 <a> 태그를 기억하면 편하다.



#### 3.2 HTTP 통신 방식
  
<img width="467" alt="스크린샷 2022-10-19 오전 7 53 16" src="https://user-images.githubusercontent.com/52316270/196642240-6ec0f6bc-3314-40a8-9d3a-ee7eb85e8bdd.png">

- 클라이언트에서 서버로 요청을 보내고 서버가 응답하는 방식으로 통신이 이루어진다.
- 응답으로는 클라이언트의 요청에 맞는 결과를 반환해준다.
- 따라서 클라이언트의 요청이 있을 때만 서버가 응답하는 방식(단방향 통신)



#### 3.3 HTTP 특징

- 클라이언트 - 서버 구조로 단방향 통신
- Stateless 지향으로 서버가 클라이언트의 연결/상태 정보를 보존하지 않는다. 따라서 이전 요청과 같은 리소스를 원해도 다시 같은 요청을 해야한다.
- 비연결성: 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않는 것으로 이를 통해 서버의 자원을 효율적으로 관리하고,  수많은 클라이언트 요청에도 대응 가능
- HTTP 메시지(요청, 응답)를 통해 통신

<img width="482" alt="스크린샷 2022-10-19 오전 8 07 00" src="https://user-images.githubusercontent.com/52316270/196642599-0325c98b-f8d0-42b7-8a4a-45ab6dce932b.png">


#### 3.4 Socket 통신

<img width="464" alt="스크린샷 2022-10-19 오전 7 56 33" src="https://user-images.githubusercontent.com/52316270/196642688-e9ce50b3-d06d-40ad-a741-b8768d97919a.png">

- 서버와 클라이언트 양방향 연결이 이루어지는 통신
- 스트리밍이나 실시간 채팅 등 실시간으로 데이터를 주고 받아야하는 경우 Connection을 자주 맺고 끊는 HTTP보 소켓 통신이 적합

> 소켓이란?
>
> 네트워크상에서 동작하는 프로그램 간 통신의 종착점(Endpoint), 접속의 끝부분.
>
> 종착점인 Endpoint는 IP주소와 Port번호의 조합으로 이루어진 최종 목적지를 나타낸다.



---



## 4. 논 블록킹, 블록킹, 동기, 비동기

참고: https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0

#### 4.1 들어가기전

- 제어권: 자신(함수) 코드를 실행할 권리 같은 것으로 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.
- 결과값을 기다린다는 것: A함수에서 B함수를 호출했을 때, A함수가 B함수의 결과를 기다리는지 여부



#### 4.2 블록킹과 논블록킹

- 블록킹과 논블록킹은 제어권을 어떻게 처리하느냐에 따라 달라지는 것

###### 블록킹

- A함수가 B함수를 호출하면, 제어권을 A가 호출한 B함수에 넘겨준다.

~~~javascript
1. A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.
2. 제어권을 넘겨받은 B는 함수를 실행하고 A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.
3. B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.
~~~

###### 논블록킹

- A함수가 B함수를 호출해도 제어권은 그대로 자신이 가지고 있는다.

~~~javascript
1. A함수가 B함수를 호출하면, B 함수는 실행되지만, 제어권은 A함수가 그대로 가지고 있는다.
2. A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.
~~~



#### 4.3 동기와 비동기

- 동기와 비동기의 차이는 호출되는 함수의 작업완료 여부를 신경쓰는지 차이

###### 동기

- 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것

###### 비동기

- 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.
- 함수 A는 함수 B를 호출한 후로 함수 B의 작업완료는 신경쓰지 않는다.



#### 4.4 블록킹, 논블록킹, 동기, 비동기 활용

###### Sync-Blocking(동기-블록킹)

<img width="437" alt="스크린샷 2022-10-19 오후 5 29 17" src="https://user-images.githubusercontent.com/52316270/196642826-343a7a71-4637-4592-b8db-266152169501.png">

- 함수 A는 함수 B의 리턴값을 필요로 한다.(동기) 그래서 제어권을 B에게 넘겨주고, 함수 B가 실행완료 후 리턴값과 제어권을 돌려줄때까지 기다린다.(블록킹)



###### Sync-Nonblocking(동기 - 논블록킹)

<img width="426" alt="스크린샷 2022-10-19 오후 5 33 16" src="https://user-images.githubusercontent.com/52316270/196642864-49d00867-0a40-4372-b729-f5f0c2d0a4de.png">

- A 함수는 B함수를 호출한다. 이 때 A함수는 B함수에게 제어권을 주지않고 자신의 코드를 실행한다(논블록킹). 동시에 A 함수는 B함수의 리턴값이 필요하기 때문에 중간중간 B함수에게 함수 실행을 완료했는지 물어본다.

###### Async-Nonblocking(비동기 - 논블록킹)
  
<img width="370" alt="스크린샷 2022-10-19 오후 5 33 49" src="https://user-images.githubusercontent.com/52316270/196642921-03fa0f97-aeb1-442e-bb33-3bebc2f33d6b.png">

- A 함수는 B 함수를 호출한다. 이 때 제어권을 B함수에 주지않고 계속 가지고 있는다(논블록킹), 따라서 B 함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행한다. 그리고 B 함수를 호출할 때 콜백함수를 같이주고 작업이 끝나면 A가 준 콜백함수를 실행한다(비동기)



###### Async-Blocking(비동기 - 블록킹)

<img width="450" alt="스크린샷 2022-10-19 오후 5 38 05" src="https://user-images.githubusercontent.com/52316270/196642962-3fdc57c0-6429-4176-bedf-811125e598c6.png">
  
- A 함수는 B 함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다(비동기). 그런데 B 함수의 작업에 관심 없음에도 A 함수는 B 함수에게 제어권을 넘긴다. 따라서, A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때 까지 기다려야 한다.
